
// Match students into study groups
export async function matchGroups() {
  let studyGroups = [];

  // Get the students' information from the database
  const students = await getStudentsInfo();

  // Assign the students to the study groups
  assignStudentsToStudyGroups(students, studyGroups);

  // Assign the remaining students to the study groups
  assignRemainingStudents(students, studyGroups);

  return studyGroups;
}

// Get the students' information from the database
export async function getStudentsInfo() {
  // let students = [];

  await wixData
    .query("Preference")
    .find()
    // Handle the returned collection of items
    .then((preferences) => {
      // Check if preferences were found
      if (preferences.items.length > 0) {
        // Iterate over the preferences
        return preferences.items.map(async (preference) => {
          await wixData
            .query("Student")
            .eq("studentId", preference.studentId)
            .find()
            .then((student) => {
              preference.name = student.items[0].name;
              preference.email = student.items[0].email;
            });

          await wixData
            .query("Course")
            .hasSome("courseId", preference.first, preference.second, preference.third)
            .find()
            .then((courses) => {
              delete preference.first;
              delete preference.second;
              delete preference.third;
              preference.prioritizedCourses = courses.items.map((course) => ({ subject: course.subject, instructor: course.instructor }));
            });

          await wixData
            .query("Student")
            .hasSome("studentId", preference.friends.split(" "))
            .find()
            .then((friends) => {
              delete preference.friends;
              preference.desiredFriends = friends.items.map((friend) => ({ studentId: friend.studentId, name: friend.name, email: friend.email }));
            });

          // students.push(preference);
          return preference;
        });
      } else {
        // Handle case where no preferences were found
        console.log("No preferences found");
      }
    })
    // Handle errors
    .catch((error) => {
      console.error(error.message);
    });

  // return students;
}

// Assign the students to the study groups
function assignStudentsToStudyGroups(students, studyGroups) {
  students.forEach((student) => {
    let isAssigned = false;

    // Iterate over the course priorities of the student
    student.prioritizedCourses.forEach((course) => {
      // Check if there are groups available for the current course
      const groupsForCourse = studyGroups.filter((group) => group.courseInfo === course);
      if (groupsForCourse.length > 0) {
        // Check if there are groups with vacancies
        const groupsWithVacancy = groupsForCourse.filter((group) => hasVacancy(group));
        if (groupsWithVacancy.length > 0) {
          // Check if there are groups among friends' groups
          const groupsWithFriends = getGroupsWithFriends(student, groupsWithVacancy);
          if (groupsWithFriends.length > 0) {
            // Select the first group among friends' groups and assign the student to it
            groupsWithFriends[0].members.push({ studentId: student.studentId, name: student.name });
          } else {
            // Select the first group with vacancies and assign the student to it
            groupsWithVacancy[0].members.push({ studentId: student.studentId, name: student.name });
          }

          isAssigned = true;
          return;
        }
      }
    });

    // If not assigned to any group, create a new group for the first course
    if (!isAssigned) {
      studyGroups.push({ courseInfo: student.prioritizedCourses[0], members: [{ studentId: student.studentId, name: student.name }] });
    }
  });
}

// Get the groups among friends' groups
function getGroupsWithFriends(student, groups) {
  const groupIdsWithFriends = student.desiredFriends.reduce((groupIds, friend) => {
    groups.forEach((group) => {
      if (group.members.some((member) => member.studentId === friend.studentId)) {
        groupIds.add(group.courseInfo);
      }
    });

    return groupIds;
  }, new Set());

  return groups.filter((group) => groupIdsWithFriends.has(group.courseInfo));
}

// Assign the remaining students to the study groups
function assignRemainingStudents(students, studyGroups) {
  students.forEach((student) => {
    // Check if the student is already assigned to a study group
    let isAssigned = studyGroups.some((studyGroup) => studyGroup.members.includes(student));
    if (!isAssigned) {
      studyGroups.forEach((studyGroup) => {
        // If the study group has a vacancy, assign the student to it
        if (hasVacancy(studyGroup)) {
          studyGroup.members.push({ studentId: student.studentId, name: student.name });
          isAssigned = true;
          return;
        }
      });

      // If the student is still not assigned to a study group, create a new one
      if (!isAssigned) {
        studyGroups.push({ courseInfo: student.prioritizedCourses[0], members: [{ studentId: student.studentId, name: student.name }] });
      }
    }
  });
}

// Check if the study group has a vacancy for another student
function hasVacancy(studyGroup) {
  return studyGroup.members.length < 4; // Max capacity: 4
}
